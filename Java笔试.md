#### socket和serversocket的区别：

客户端通过socket()方法创建socket对象 

```
Socket socket=new Socket();
```

服务端通过serverSocket()方法创建TCP对象,通过accept()方法接受客户端请求。

```
ServerSocket serverSocket=new ServerSocket();
```



------



#### Java三大注解分别是@Override @Deprecated @Suppresswarnings 

```java
1.@Override 注解表名子类中覆盖了超类中的某个方法，如果写错了覆盖形式，编译器会报错 。

2.@Deprecated 表明不希望别人在以后使用这个类，方法，变量等等 。

3.@Suppresswarnings 达到抑制编译器产生警告的目的，但是不建议使用，因为后期编码人员看不懂编译器提示的警告，不能更好的选择更好的类去完成任务。
```

------



#### 抽象类和接口的区别：

  1.抽象类可以有构造函数，接口不可以有构造函数 ；

  2.抽象类中可以有普通成员变量，接口中没有普通成员变量，只能有常量；

  3.抽象类中的方法可以被static修饰，接口中的方法不可以被static修饰；

  4.抽象类中可以有普通方法和抽象方法，接口中的方法全是抽象方法；

  5.一个类只能继承一个抽象类，接口可以被多实现，即一个类只能继承一个类，可以实现多个接口 。

  6.从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

  ###### 何时使用 ：

  接口主要用于模块与模块之间的调用。主要用接口来实现多继承，因为java不支持类的多继承，只能用接口 

  抽象类主要用于当做基础类使用，即基类。如果想拥有一些方法，并且这些方法有默认实现，那么使用抽象类





接口中字段的修饰符：public static final（默认不写）

接口中方法的修饰符：public abstract（默认不写）

------


​	

#### String、StringBuffer、StringBuilder的区别：

String 字符串常量，是不可变的对象，因此每次对 String 类型进行改变的时，等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象

 StringBuffer 字符串变量（线程安全）

 StringBuilder 字符串变量（非线程安全）

执行速度、效率：StringBuilder > StringBuffer > String

线程安全：StringBuilder是线程不安全的，而StringBuffer是线程安全的

所以多线程使用字符串缓冲区时，使用StringBuffer，如果是单线程，使用StringBuiler效率更高一些。
	
	

------

#### Collections,collection 的区别

Collection 是个 java.util 下的接口，它是各种集合结构的父接口。

Collections 是个java.util 下的普通类，它包含有各种有关集合操作的静态方法。

 Collections 是针对集合类的一个帮助类， 它提供一系列的静态方法实现对各种集合的搜索， 排序， 线程安全化等操作。	

------

#### sleep() 和 wait() 区别

> **sleep() 方法：**线程主动放弃 CPU，使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。典型地， sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足止。
>
> **wait( ) ：**与 notify() 配套使用， wait() 使得线程进入阻塞状态，它有两种形式，一种允许指定以毫秒为单位的一段时间作为参数， 另一种没有参数， 当指定时间参数时对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态， 后者则必须对应的 notify() 被调用。

------

#### List 、Map、Set 三个接口存储元素时各有什么特点？

**List** 是有序的 Collection ，使用此接口能够精确的控制每个元素插入的位置。 用户能够使用索引（元素在 List 中的位置，类似于数组下标）来访问 List 中的元素，这类似于Java 的数组。

**Set** 是一种不包含重复的元素的 Collection ，即任意的两个元素 e1 和 e2 都有e1.equals(e2)=false ，Set 最多有一个 null 元素。

**Map**接口：请注意， Map没有继承 Collection 接口， Map提供 key 到 value 的映射

------

#### forward 和 redirect 的区别

forward 是容器中控制权的转向，是服务器请求资源，服务器直接访问目标地址的 URL，把那个 URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。

 redirect 就是服务端根据逻辑 , 发送一个状态码 , 告诉浏览器重新去请求那个地址， 一般来说浏览器会用刚才请求的所有参数重新请求， 并且从浏览器的地址栏中可以看到跳转后的链接地址。 前者更加高效，在前者可以满足需要时，尽量使用 forward() 方法，并且，这样也有助于隐藏实际的链 接 ； 在 有 些 情 况 下 ， 比 如 ， 需 要 跳 转 到 一 个 其 它 服 务 器 上 的 资 源 ， 则 必 须 使 用sendRedirect() 方法。

------

#### java 泛型

在 Java SE 1.5 之前，没有泛型的情况的下，通过对类型 Object 的引用来实现参数的 “任意化”，“任意化”带来的缺点是要做显式的强制类型转换， 而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。 对于强制类型转换错误的情况， 编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。

泛型是 Java SE 1.5 的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 这种参数类型可以用在类、接口和方法的创建中， 分别称为泛型类、泛型接口、泛型方法。泛型的好处是在编译的时候检查类型安全， 并且所有的强制转换都是自动和隐式的， 提高代码的重用率。

------

#### final,finally,finaliz 的区别

final —修饰符（关键字）如果一个类被声明为 final ，意味着它不能再派生出新的子类，不能作为父类被继承。 因此一个类不能既被声明为 abstract 的，又被声 明为 final的。将变量或方法声明为 final ，可以保证它们在使用中不被改变。被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改 被声明为 final 的方法也同样只能使用，不能重载。

finally —再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常 ，那么相匹配的 catch 子句就会执行， 然后控制就会进入 finally 块（如果有的话） 。

 finalize —方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。 这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 ；finalize() 方法以整理系统资源或者执行其他清理工作 finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。

------

#### ArrayList,Vector, LinkedList 的存储性能和特性？

ArrayList 采用的是数组形式来保存对象的，这种方式将对象放在连续的位置中，所以最大的缺点就是插入删除时非常麻烦 LinkedList 采用的将对象存放在独立的空间中，而且在每个空间中还保存下一个链接的索引 但是缺点就是查找非常麻烦 要丛第一个索引开始

ArrayList 和 Vector 都是用数组方式存储数据 , 此数组元素数要大于实际的存储空间以便进行元素增加和插入操作 , 他们都允许直接用序号索引元素 , 但是插入数据元素涉及到元素移动等内存操作 , 所以索引数据快而插入数据慢 . 

Vector 使用了 sychronized 方法 ( 线程安全 ), 所以在性能上比 ArrayList 要差些 . 

LinkedList 使用双向链表方式存储数据 , 按序号索引数据需要前向或后向遍历数据，所以索引数据慢 , 是插入数据时只需要记录前后项即可 , 所以插入的速度快 . 

------

